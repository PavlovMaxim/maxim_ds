# Теория
## Введение
Дерево - это иерархическая структура данных, состоящая из узлов, соединенных ребрами.
Каждый узел содержить в себе данные и связан с другими узалми в отношении родитель-потомок.

### Бинарное дерево
Дерево, где каждый узел имеет не более двух потомков (левый и правый).
Каждый элемент бинарного дерево называется узлом. Связи между узлами называются его ветвями.

### Бинарное дерево поиска (BST)
Бинарное дерево, для каждого узла которого справедливо условие, что значение левого дочернего элемента
меньше значения узла, а значение правого дочернего элемента больше. (p.s. BST используется в красно-черном дереве и тд с использованием балансировки).

### Сбалансированное бинарное дерево
Дерево, в котором разница в высоте между левым и правым поддеревьями минимально (чаще всего не более 1).

## Виды обхода бинарного дерева
Примеры вывода обходов написаны для дерева:
       4
      / \
     2   6
    / \ / \
   1  3 5  7

### Inorder обход

#### Порядок:
Лево -> действие -> право (Если корень равен NULL, вернуть -> рекурсивно обойти левое поддерево -> обработать корневой узел -> рекурсивно обойти правое поддерево)

#### Псведокод:
void inOrder(Node* node) {
    if (node == nullptr) return;
    inOrder(node->left);
    visit(node);
    inOrder(node->right);
}

#### Вывод:
1, 2, 3, 4, 5, 6, 7

#### Сложность:
Временная сложность: O(n), n — общее количество узлов.
Вспомогательное пространство: O(h), h — высота дерева.

В худшем случае h может быть таким же, как N (когда дерево является перекошенным).
В лучшем случае h может быть таким же, как log N (когда дерево является полным деревом).

#### Используется для:
сортировки BST

### Preorder обход

#### Порядок:
Действие -> лево -> право (Если корень равен NULL, вернуть -> обработать корневой узел -> рекурсивно обойти левое поддерево -> рекурсивно обойти правое поддерево)

#### Псведокод:
void preOrder(Node* node) {
    if (node == nullptr) return;
    visit(node);
    preOrder(node->left);
    preOrder(node->right);
}

#### Вывод:
4, 2, 1, 3, 6, 5, 7

#### Сложность:
Временная сложность: O(n), n — общее количество узлов.
Вспомогательное пространство: O(h), h — высота дерева.

В худшем случае h может быть таким же, как N (когда дерево является перекошенным).
В лучшем случае h может быть таким же, как log N (когда дерево является полным деревом).

#### Используется для:
Копирования дерева, сериализации, выражений в префиксной нотации

### Post-order обход

#### Порядок:
Лево -> право -> действие (Если корень равен NULL, вернуть -> рекурсивно обойти левое поддерево -> рекурсивно обойти правое поддерево -> обработать корневой узел)

#### Псведокод:
void postOrder(Node* node) {
    if (node == nullptr) return;
    postOrder(node->left);
    postOrder(node->right);
    visit(node);
}

#### Вывод:
1, 3, 2, 5, 7, 6, 4

#### Сложность:
Временная сложность: O(n), n — общее количество узлов.
Вспомогательное пространство: O(h), h — высота дерева.

В худшем случае h может быть таким же, как N (когда дерево является перекошенным).
В лучшем случае h может быть таким же, как log N (когда дерево является полным деревом).

#### Используется для:
Используется для удаления дерева, поскольку поддеревья удаляются до текущего узла.

### Level-order обход

#### Порядок:
Уровень за уровнем слева направо
- Использует очередь (FIFO)
- Реализует Breadth-First Search (BFS)

## Основные операции